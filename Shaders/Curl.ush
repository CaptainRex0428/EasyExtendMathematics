// ============================================
// Curl Noise 实现（基于https://www.cnblogs.com/idovelemon/p/12775127.html的方法）
// ============================================

#pragma once

#include "/Engine/Private/Common.ush"

// 2D Curl Noise（推荐用于2D效果）
// ============================================
// 输入：单通道噪声纹理（只用R通道）
// 输出：2D向量场
// SampleOffset 0.0001f
float2 CurlNoise2D(Texture2D NoiseTexture, SamplerState NoiseSampler, 
				   float2 UVs, float SampleOffset)
{
	float2 uv = UVs;
	float h = SampleOffset;
    
	// 采样中心点和2个相邻点（只使用R通道）
	
	float n = Texture2DSample(NoiseTexture, NoiseSampler, uv).r;
	float n_down = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(0, h)).r;  // y-h
	float n_left = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, 0)).r;  // y-h
    
	// 后向差分法（Backward Difference）
	// ∂N/∂y ≈ (N(x,y) - N(x,y-h)) / h
	// ∂N/∂x ≈ (N(x,y) - N(x-h,y)) / h
	float dN_dy = (n - n_down) / h;
	float dN_dx = (n - n_left) / h;
    
	// 2D Curl公式: (∂N/∂y, -∂N/∂x)
	return float2(dN_dy, -dN_dx);
}

// 2D Curl Noise 中心差分法（更精确但需要更多采样）
// ============================================
float2 CurlNoise2D_Central(Texture2D NoiseTexture, SamplerState NoiseSampler, 
						   float2 UVs, float SampleOffset)
{
	float2 uv = UVs;
	float h = SampleOffset;
    
	// 采样4个方向（中心差分需要正负两边）
	float n_right = Texture2DSample(NoiseTexture, NoiseSampler, uv + float2(h, 0)).r;
	float n_left  = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, 0)).r;
	float n_up    = Texture2DSample(NoiseTexture, NoiseSampler, uv + float2(0, h)).r;
	float n_down  = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(0, h)).r;
    
	// 中心差分: ∂N/∂x ≈ (N(x+h) - N(x-h)) / (2h)
	float dN_dx = (n_right - n_left) / (2.0 * h);
	float dN_dy = (n_up - n_down) / (2.0 * h);
    
	// 2D Curl
	return float2(dN_dy, -dN_dx);
}


// 3D Curl Noise（用于3D粒子效果）
// ============================================
// 输入：单通道噪声纹理（只用R通道）
// 输出：3D向量场
float3 CurlNoise3D(Texture2D NoiseTexture, SamplerState NoiseSampler, 
				   float2 UVs, float SampleOffset)
{
	float2 uv = UVs;
	float h = SampleOffset;
    
	// 注意：这里我们在2D纹理上模拟3D noise
	// 可以通过不同的UV偏移来模拟z方向
    
	// 采样中心点
	float n = Texture2DSample(NoiseTexture, NoiseSampler, uv).r;
    
	// 采样3个方向的点（使用后向差分）
	float n_x = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, 0)).r;     // x-h
	float n_y = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(0, h)).r;     // y-h
    
	// 模拟z方向：使用稍微不同的采样模式或者额外的纹理
	// 这里用对角线方向来近似z方向
	float n_z = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, h) * 0.707).r;
    
	// 计算三个方向的偏导数
	float dN_dx = (n - n_x) / h;
	float dN_dy = (n - n_y) / h;
	float dN_dz = (n - n_z) / h;
    
	// 3D Curl公式: curl = (∂N/∂y - ∂N/∂z, ∂N/∂z - ∂N/∂x, ∂N/∂x - ∂N/∂y)
	float3 curl = float3(
		dN_dy - dN_dz,
		dN_dz - dN_dx,
		dN_dx - dN_dy
	);
    
	return curl;
}

// 3D Curl（使用3D噪声纹理）
// ============================================
// 如果你有3D纹理资源
float3 CurlNoise3D_Volume(Texture3D NoiseTexture3D, SamplerState NoiseSampler, 
						float3 Position, float SampleOffset)
{
	float3 pos = Position;
	float h = SampleOffset;
    
	// 采样中心点
	float n = Texture3DSample(NoiseTexture3D, NoiseSampler, pos).r;
    
	// 采样3个方向（后向差分）
	float n_x = Texture3DSample(NoiseTexture3D, NoiseSampler, pos - float3(h, 0, 0)).r;
	float n_y = Texture3DSample(NoiseTexture3D, NoiseSampler, pos - float3(0, h, 0)).r;
	float n_z = Texture3DSample(NoiseTexture3D, NoiseSampler, pos - float3(0, 0, h)).r;
    
	// 计算偏导数
	float dN_dx = (n - n_x) / h;
	float dN_dy = (n - n_y) / h;
	float dN_dz = (n - n_z) / h;
    
	// 3D Curl公式
	float3 curl = float3(
		dN_dy - dN_dz,
		dN_dz - dN_dx,
		dN_dx - dN_dy
	);
    
	return curl;
}

// 3D Curl 使用RGB三通道分别计算三个独立的curl
// ============================================
// 如果你的噪声纹理RGB通道是三个独立的噪声
float3 CurlNoise3D_MultiChannel(Texture2D NoiseTexture, SamplerState NoiseSampler, 
							  float2 UVs, float SampleOffset)
{
	float2 uv = UVs;
	float h = SampleOffset;
    
	// 分别计算三个通道的curl（每个通道独立计算）
	float3 curl;
    
	// R通道的2D curl -> XY分量
	float r = Texture2DSample(NoiseTexture, NoiseSampler, uv).r;
	float r_left = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, 0)).r;
	float r_down = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(0, h)).r;
	
	float dR_dx = (r - r_left) / h;
	float dR_dy = (r - r_down) / h;
	curl.x = dR_dy;
	curl.y = -dR_dx;
    
	// G通道的curl -> Z分量
	float g = Texture2DSample(NoiseTexture, NoiseSampler, uv).g;
	float g_left = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(h, 0)).g;
	float g_down = Texture2DSample(NoiseTexture, NoiseSampler, uv - float2(0, h)).g;
	float dG_dx = (g - g_left) / h;
	float dG_dy = (g - g_down) / h;
	curl.z = dG_dx - dG_dy;
    
	return curl;
}

float3 GetCamWP(FMaterialPixelParameters Parameters)
{
	float3 worldPos = Parameters.WorldPosition_CamRelative;
	return worldPos;
}

// 3D Curl 使用Curl2D Central分别计算三个独立的通道结果
// ============================================
// 如果你的噪声纹理RGB通道是三个独立的噪声
float3 CurlNoise3D_Combine(Texture2D NoiseTexture, SamplerState NoiseSampler,
	float3 Position,
	float2 ScaleX, float2 OffsetX,
	float2 ScaleY, float2 OffsetY,
	float2 ScaleZ, float2 OffsetZ, float SampleOffset)
{
	float3 pos = Position;
	
	float2 CurlX = CurlNoise2D(NoiseTexture, NoiseSampler, pos.gb * ScaleX + OffsetX, SampleOffset);
	float2 CurlY = CurlNoise2D(NoiseTexture, NoiseSampler, pos.rb * ScaleY + OffsetY, SampleOffset);
	float2 CurlZ = CurlNoise2D(NoiseTexture, NoiseSampler, pos.rg * ScaleZ + OffsetZ, SampleOffset);

	float3 curl3D;
	curl3D.x = CurlX.x * 0.7 + CurlZ.y * 0.3;
	curl3D.y = CurlY.x * 0.7 + CurlX.y * 0.3;
	curl3D.z = CurlZ.x * 0.7 + CurlY.y * 0.3;

	return curl3D;
}

// 3D Curl 使用Curl2D Central分别计算三个独立的通道结果
// ============================================
// 如果你的噪声纹理RGB通道是三个独立的噪声
float3 CurlNoise3D_Combine_Central(Texture2D NoiseTexture, SamplerState NoiseSampler,
	float3 Position,
	float2 ScaleX, float2 OffsetX,
	float2 ScaleY, float2 OffsetY,
	float2 ScaleZ, float2 OffsetZ, float SampleOffset)
{
	float3 pos = Position;
	
	float2 CurlX = CurlNoise2D_Central(NoiseTexture, NoiseSampler, pos.gb * ScaleX + OffsetX, SampleOffset);
	float2 CurlY = CurlNoise2D_Central(NoiseTexture, NoiseSampler, pos.rb * ScaleY + OffsetY, SampleOffset);
	float2 CurlZ = CurlNoise2D_Central(NoiseTexture, NoiseSampler, pos.rg * ScaleZ + OffsetZ, SampleOffset);

	float3 curl3D;
	curl3D.x = CurlX.x * 0.7 + CurlZ.y * 0.3;
	curl3D.y = CurlY.x * 0.7 + CurlX.y * 0.3;
	curl3D.z = CurlZ.x * 0.7 + CurlY.y * 0.3;

	return curl3D;
}
