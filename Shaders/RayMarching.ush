#pragma once

#include "/Engine/Private/Common.ush"

// used for obsidian internal impurities
half LavaNoiseInnerMarching(
    Texture2D VolumeNoise,
    SamplerState VolumeNoiseSampler,
    float3 ViewDirection,
    float3 NormalVector,
    float3 Position,
    float3 RefractionSurfaceNoise,
    float Refraction,
    float StepLength,
    int StepCount,
    float3 LinearMaskVector,
    float LinearMaskOffset,
    float LinearMaskScale,
    float LinearMaskNegate,
    float NoiseScale,
    float NoiseStrength,
    float NoiseExp,
    float NoiseIntersection,
    float WeightScale,
    out float3 DebugRefractVector,
    out half DebugLinearMask,
    out half DebugVoronoi,
    out half DebugCloud)
{
    float VolumeNoiseScale  =   NoiseScale * 0.001;

    float2 OutputPom;

    float StepDistance = .0f;
    OutputPom.r = .0f;
    OutputPom.g = .0f;

    ViewDirection = normalize(ViewDirection);
    NormalVector = normalize(NormalVector);

    // 假设从空气(IOR=1.0)进入材质
    // float IORRatio = 1.0 / Refraction;  // Refraction 应该是材质的IOR值

    // 添加表面扰动，作用在法线上
    // float3 PerturbedNormal = normalize(NormalVector + RefractionSurfaceNoise);
    
    // float3 RefractVector = refract(ViewDirection, PerturbedNormal, IORRatio);

    float IORRatio = saturate(1-(RefractionSurfaceNoise/Refraction));
    float3 RefractVector = refract(ViewDirection,NormalVector,IORRatio);

    float3 SampledPosition, SampledCustomNoise;
    float LinearMask;

    float WeightR = 0.0f;
    float WeightG = 0.0f;
    
    float StepSize = StepLength / (float)StepCount;


    for (int MarchingIdx = 0; MarchingIdx < StepCount; ++MarchingIdx)
    {
        SampledPosition = Position + RefractVector * StepDistance;
        SampledPosition *= VolumeNoiseScale;

        float3 sampledCustomNoiseXY = Texture2DSample(VolumeNoise, VolumeNoiseSampler, SampledPosition.xy );
        float3 sampledCustomNoiseZY = Texture2DSample(VolumeNoise, VolumeNoiseSampler, SampledPosition.zy + float2(144.23, 5444.12));
        float3 sampledCustomNoiseXZ = Texture2DSample(VolumeNoise, VolumeNoiseSampler, SampledPosition.xz + float2(3127.11, 1522.12));

        SampledCustomNoise = sampledCustomNoiseXY * sampledCustomNoiseZY * sampledCustomNoiseXZ;

        LinearMask = saturate((saturate(dot(SampledPosition, LinearMaskVector) + LinearMaskOffset) * LinearMaskScale) + LinearMaskNegate);

        float WeightX = saturate(1.0-((float)MarchingIdx/(float)StepCount));
        OutputPom.r += saturate((SampledCustomNoise.x * NoiseStrength))  * LinearMask * WeightX;

        float WeightY = saturate(((float)MarchingIdx + 1)/(float)StepCount);
        OutputPom.g += pow(SampledCustomNoise.y, NoiseExp) * LinearMask * 2 * saturate((MarchingIdx + 1)/StepCount);

        WeightR += WeightX;
        WeightG += WeightY;

        StepDistance += (StepSize);
    }

    OutputPom.r /= WeightR;
    OutputPom.g /= WeightG;

    OutputPom *= WeightScale;

    DebugCloud = OutputPom.r;
    DebugVoronoi = OutputPom.g;
    DebugRefractVector = RefractVector;
    DebugLinearMask = LinearMask;

    return OutputPom.r  + (saturate(OutputPom.r + (1 - NoiseIntersection)) * OutputPom.g );

}
